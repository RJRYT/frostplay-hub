<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frost Runner - FrostPlay</title>
    <meta name="description" content="Navigate through icy obstacles in this fast-paced endless runner with stunning visual effects.">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Frost Runner - FrostPlay">
    <meta property="og:description" content="Navigate through icy obstacles in this fast-paced endless runner with stunning visual effects.">
    <meta property="og:image" content="/games/frost-runner/thumbnail.png">
    <meta property="og:type" content="website">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Frost Runner - FrostPlay">
    <meta name="twitter:description" content="Navigate through icy obstacles in this fast-paced endless runner with stunning visual effects.">
    <meta name="twitter:image" content="/games/frost-runner/thumbnail.png">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        
        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            z-index: 10;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 20;
            display: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="loading" id="loading">Loading Frost Runner...</div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div class="game-ui" id="gameUI">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">1.0x</span></div>
        </div>
        
        <div class="instructions">
            <div style="font-weight: bold; margin-bottom: 8px;">Controls:</div>
            <div>Space/â†‘ - Jump</div>
            <div>R - Restart</div>
            <div>ESC - Pause</div>
        </div>
        
        <div class="game-over" id="gameOver">
            <h1>Game Over!</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Press R to restart</p>
        </div>
    </div>

    <script>
        // Frost Runner Game
        class FrostRunner {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loading = document.getElementById('loading');
                this.gameUI = document.getElementById('gameUI');
                this.gameOverScreen = document.getElementById('gameOver');
                
                this.init();
            }
            
            init() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.gameState = {
                    player: { x: 100, y: 200, width: 30, height: 30, dy: 0, grounded: false },
                    obstacles: [],
                    particles: [],
                    score: 0,
                    gameSpeed: 2,
                    gameRunning: true,
                    paused: false,
                    keys: {}
                };
                
                this.setupControls();
                this.loading.style.display = 'none';
                this.gameLoop();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                if (this.gameState) {
                    this.gameState.player.y = this.canvas.height - 100;
                }
            }
            
            setupControls() {
                document.addEventListener('keydown', (e) => {
                    this.gameState.keys[e.key] = true;
                    
                    if (e.key === ' ' || e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (this.gameState.player.grounded && this.gameState.gameRunning) {
                            this.gameState.player.dy = -15;
                            this.gameState.player.grounded = false;
                            this.createParticles(this.gameState.player.x, this.gameState.player.y + this.gameState.player.height);
                        }
                    }
                    
                    if (e.key === 'Escape') {
                        this.gameState.paused = !this.gameState.paused;
                    }
                    
                    if (e.key === 'r' || e.key === 'R') {
                        this.restart();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.gameState.keys[e.key] = false;
                });
                
                // Touch controls for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameState.player.grounded && this.gameState.gameRunning) {
                        this.gameState.player.dy = -15;
                        this.gameState.player.grounded = false;
                    }
                });
            }
            
            createParticles(x, y) {
                for (let i = 0; i < 5; i++) {
                    this.gameState.particles.push({
                        x: x + Math.random() * 30,
                        y: y,
                        dx: (Math.random() - 0.5) * 4,
                        dy: -Math.random() * 3,
                        life: 30,
                        maxLife: 30
                    });
                }
            }
            
            updateParticles() {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.dy += 0.1;
                    particle.life--;
                    return particle.life > 0;
                });
            }
            
            drawParticles() {
                this.gameState.particles.forEach(particle => {
                    const alpha = particle.life / particle.maxLife;
                    this.ctx.save();
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = '#00ccff';
                    this.ctx.fillRect(particle.x, particle.y, 2, 2);
                    this.ctx.restore();
                });
            }
            
            generateObstacle() {
                if (Math.random() < 0.008 + this.gameState.score * 0.000001) {
                    this.gameState.obstacles.push({
                        x: this.canvas.width,
                        y: this.canvas.height - 80,
                        width: 30 + Math.random() * 20,
                        height: 50 + Math.random() * 30
                    });
                }
            }
            
            updateGame() {
                if (!this.gameState.gameRunning || this.gameState.paused) return;
                
                // Player physics
                this.gameState.player.dy += 0.8;
                this.gameState.player.y += this.gameState.player.dy;
                
                // Ground collision
                const groundY = this.canvas.height - 50;
                if (this.gameState.player.y + this.gameState.player.height > groundY) {
                    this.gameState.player.y = groundY - this.gameState.player.height;
                    this.gameState.player.dy = 0;
                    this.gameState.player.grounded = true;
                }
                
                // Generate obstacles
                this.generateObstacle();
                
                // Update obstacles
                this.gameState.obstacles = this.gameState.obstacles.filter(obstacle => {
                    obstacle.x -= this.gameState.gameSpeed;
                    
                    // Collision detection
                    if (this.checkCollision(this.gameState.player, obstacle)) {
                        this.gameOver();
                    }
                    
                    return obstacle.x > -obstacle.width;
                });
                
                // Update particles
                this.updateParticles();
                
                // Update score and speed
                this.gameState.score += 1;
                this.gameState.gameSpeed = 2 + this.gameState.score * 0.001;
                
                // Update UI
                document.getElementById('score').textContent = this.gameState.score;
                document.getElementById('speed').textContent = this.gameState.gameSpeed.toFixed(1) + 'x';
            }
            
            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }
            
            drawBackground() {
                // Gradient background
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Moving background elements
                this.ctx.fillStyle = '#00ccff20';
                for (let i = 0; i < 8; i++) {
                    const x = (Date.now() * 0.05 + i * 150) % (this.canvas.width + 100) - 100;
                    this.ctx.fillRect(x, i * 80, 60, 15);
                }
            }
            
            drawGame() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawBackground();
                
                // Draw ground with glow
                const groundY = this.canvas.height - 50;
                this.ctx.shadowColor = '#00ccff';
                this.ctx.shadowBlur = 20;
                this.ctx.fillStyle = '#00ccff';
                this.ctx.fillRect(0, groundY, this.canvas.width, 50);
                
                // Ground highlight
                this.ctx.shadowBlur = 30;
                this.ctx.fillRect(0, groundY, this.canvas.width, 5);
                this.ctx.shadowBlur = 0;
                
                // Draw player with glow
                this.ctx.shadowColor = '#ff6b6b';
                this.ctx.shadowBlur = 15;
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.fillRect(
                    this.gameState.player.x,
                    this.gameState.player.y,
                    this.gameState.player.width,
                    this.gameState.player.height
                );
                this.ctx.shadowBlur = 0;
                
                // Draw obstacles with glow
                this.ctx.shadowColor = '#ffd93d';
                this.ctx.shadowBlur = 10;
                this.ctx.fillStyle = '#ffd93d';
                this.gameState.obstacles.forEach(obstacle => {
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                });
                this.ctx.shadowBlur = 0;
                
                // Draw particles
                this.drawParticles();
                
                // Draw pause overlay
                if (this.gameState.paused) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                    this.ctx.font = '24px Arial';
                    this.ctx.fillText('Press ESC to resume', this.canvas.width / 2, this.canvas.height / 2 + 50);
                    this.ctx.textAlign = 'left';
                }
            }
            
            gameOver() {
                this.gameState.gameRunning = false;
                this.gameOverScreen.style.display = 'block';
                document.getElementById('finalScore').textContent = this.gameState.score;
                
                // Save high score
                const highScore = localStorage.getItem('frostRunnerHighScore') || 0;
                if (this.gameState.score > highScore) {
                    localStorage.setItem('frostRunnerHighScore', this.gameState.score);
                }
            }
            
            restart() {
                this.gameState = {
                    player: { x: 100, y: this.canvas.height - 100, width: 30, height: 30, dy: 0, grounded: false },
                    obstacles: [],
                    particles: [],
                    score: 0,
                    gameSpeed: 2,
                    gameRunning: true,
                    paused: false,
                    keys: {}
                };
                
                this.gameOverScreen.style.display = 'none';
            }
            
            gameLoop() {
                this.updateGame();
                this.drawGame();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new FrostRunner();
        });
        
        // Service worker registration for offline support
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(console.error);
        }
    </script>
</body>
</html>